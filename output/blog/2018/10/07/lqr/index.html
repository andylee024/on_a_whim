<!DOCTYPE HTML>
<html lang='en'>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="/style.css">
<link href='https://fonts.googleapis.com/css?family=Merriweather+Sans:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oranienbaum' rel='stylesheet' type='text/css'>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<meta content='nanoc 4.9.9' name='generator'>
<title>
LQR
[On a Whim]
</title>
</head>
<body>
<div id='title'>
<a title="Main page" href="/">On a Whim</a>
<div id='nav'>
<ul>
<li>
<a title="About the author, the website, etc." href="/about/">About</a>
</li>
<li>
<a title="Technical Content" href="/blog/">Technical Content</a>
</li>
<li>
<a title="Startup Content" href="/startup_blog/">Startup Content</a>
</li>
</ul>
</div>
</div>
<hr>
<div id='main'>
<div id='post'>
<h1>
LQR
</h1>
<aside class='posted_at'>
Posted at 2018-10-07 20:18
</aside>
<aside class='abstract'>
<b>Abstract:</b>
LQR is useful.
</aside>
<article>
<p>Compile-time computation has obvious appeal: any work you do when you <em>build</em> the program is already done when you <em>run</em> it â€“ hence, faster programs.</p>
<h3 id="lqr">LQR</h3>
<p>LQR stands for linear quadratic regulator.</p>
<p>Consider the gradient <span class="math inline">\(\nabla_{u}G\)</span>. <span class="math display">\[\nabla_{u}G = \frac{\partial}{\partial u}(x^{T}Qx) + \frac{\partial}{\partial u}(u^{T}Ru) + \frac{\partial}{\partial u}(V_{t}(Ax + Bu)) \]</span> The recursive solution to <span class="math inline">\(V_{t}(\cdot)\)</span> takes the quadratic form, <span class="math inline">\(x_{t}P_{t}x_{t}\)</span>, where <span class="math inline">\(P_{t}\)</span> is semipositive-definite. Substituting this solution in, we obtain</p>
<p><span class="math display">\[\begin{align*}
\nabla_{u}G &amp;= \frac{\partial}{\partial u}(x^{T}Qx) + \frac{\partial}{\partial u}(u^{T}Ru) + \frac{\partial}{\partial u}\bigg((Ax+Bu)^{T}P_{t}(Ax+Bu)\bigg) \\
&amp;= 0 + 2u^{T}R + \frac{\partial}{\partial u}\bigg(u^{T}B^{T}P_{t}Bu + x^{T}AP_{t}Ax + 2(u^{T}B^{T}P_{t}Ax)\bigg) \text{ (by claim 1.1) }\\
&amp;= 2u^{T}R + \frac{\partial}{\partial u}(u^{T}B^{T}P_{t}Bu) + \frac{\partial}{\partial u}(x^{T}AP_{t}Ax) + \frac{\partial}{\partial u}2(u^{T}B^{T}P_{t}Ax) \\
&amp;= 2u^{T}R + 2u^{T}B^{T}P_{t}B + 2B^{T}P_{t}Ax
\end{align*}\]</span></p>
<p>Now if we set the gradient to <span class="math inline">\(0\)</span>, we can solve for <span class="math inline">\(u^{*}\)</span>. Note that <span class="math inline">\(u^{*}\)</span> is the optimal solution for <span class="math inline">\(u_{t}\)</span>. After working the solution out, we arrive at the following set of equations. <span class="math display">\[\begin{align}
u^{*} &amp;= K_{t}x \\
K_{t} &amp;= -(R + B^{T}P_{t}B)^{-1}(B^{T}P_{t}Ax)
\end{align}\]</span></p>
<p><span class="math display">\[\binom{n}{k} = \binom{n-1}{k-1} + \binom{n-1}{k}.\]</span></p>
<p>The base cases for <span class="math inline">\(n\)</span>-choose-<span class="math inline">\(k\)</span> occur when we choose all of the items, or none of them. In either case, the answer is 1: there is exactly one way to do that.</p>

</article>
</div>

</div>
</body>
</html>
